You are absolutely right! My apologies for that oversight. We are using **Svelte with Vite** for the frontend, and while `npm run build` might be an alias in a `package.json`, the direct command for Vite is different.

I've cross-referenced the Artivus Engine PRD and our technical assumptions to ensure the build command is accurate for our Vite-based SvelteKit frontend.

Here is the corrected `.cursorrules` file in markdown format:

```markdown
# .cursorrules

## Frontend: Svelte & SvelteKit with Vite

### Components & Naming
- Use Svelte components (`.svelte` files).
- Name component files and exported modules/classes in **PascalCase** (e.g., `WaveformDisplay.svelte`). Place components under `src/lib/components/`.
- Keep components small and focused, with props typed using TypeScript interfaces in `<script lang="ts">`.
- UI styling is custom via Svelte's scoped styles (`<style>`) or global CSS. **Never use Tailwind, Radix, or Shadcn for UI components.**

### State Management
- Use Svelte's built-in reactive statements and stores (`writable`, `readable`, `derived`).
- Organize global stores in `src/lib/stores/` (e.g., `projectStore.ts`).

### Structure & Routing (SvelteKit)
- Use SvelteKit's App Router (file-system based) in `src/routes/`.
- Use `.env` files for secrets, accessed via SvelteKit's environment modules.

## Performance-Critical Logic: Rust & WebAssembly (WASM)

### Rust Modules
- Implement performance-critical audio analysis, DSP, etc., in Rust.
- Organize Rust crates in `crates/` or `packages/rust-modules/`.
- Compile to WASM using `wasm-pack`.
- Use `wasm-bindgen` for typed JS/TS <-> WASM interfaces.

### Libraries
- Leverage Essentia.js (WASM) for audio analysis.
- For real-time audio DSP, use performant WASM libraries (e.g., SoundTouchJS via WASM) or custom Rust, integrated via AudioWorklets.

## Media Handling & Rendering

### Audio
- Use **Web Audio API** for playback, scheduling, AudioWorklets.
- Custom canvas rendering for waveform display.

### Video
- Use **WebCodecs API** for video frame access/decoding.
- Use **WebGL2** for video rendering and real-time shader effects.

### Export
- Client-side export with **MediaRecorder API** (target WebM/MP4).
- (Post-MVP: `ffmpeg.wasm` for robust MP4).

## Backend Service (MVP Minimal)

- Primarily for media uploads.
- Architect to choose **Rust (Actix/Axum)** or **Node.js/Express**.
- Secure file handling, simple REST endpoints. No DB/auth for MVP.

## Monorepo & Build System

- Use a **Monorepo structure** (e.g., pnpm workspaces, Turborepo).
- Use **Vite** for Svelte frontend build system (e.g., `vite build` command for the frontend package).

## Icons

- Prefer **`svelte-lucide`** or direct **SVG** imports.
- Name icon components in **PascalCase**.
- Custom SVGs in `src/lib/components/icons/`.

## Toast Notifications

- Use a Svelte-compatible library (e.g., **`svelte-french-toast`**) or custom Svelte component.
- Use `toast.success()`, `toast.error()`, etc.

## TypeScript & Syntax

- Use **TypeScript** for Svelte and any Node.js backend.
- Strict mode enabled. Avoid `any`.
- Use optional chaining, union types (no enums for simplicity where string literal unions suffice).

## File & Folder Names

- Svelte component files: `PascalCase.svelte`.
- SvelteKit routes: kebab-case for folders.
- Utility/library TS files: `camelCase.ts` or `PascalCase.ts`.
- Shared types in `src/lib/types/index.ts` or domain-specific files.
- Sort imports (external → SvelteKit (`$app`, `$lib`) → internal absolute → relative → styles).

## Styling & Animations

- **No Tailwind CSS.** Custom styling for "rust-peaks" dark theme.
- Use **Svelte's built-in transitions/animations** (`svelte/transition`, `svelte/animate`, `svelte/motion`).

## Background Jobs / Heavy Processing (Client-Side Focus for MVP)

- Use Web Workers for lengthy client-side Rust/WASM tasks to avoid main thread blocking.
- (Post-MVP: Backend offloading consideration).

## AI (Audio Analysis)

- Implemented in **Rust/WASM modules**.
- Leverage **Essentia.js (WASM port)** or custom Rust algorithms.
- No generative AI for core MVP.

## Storybook

- Place stories in `src/stories` with `.stories.svelte` or `.stories.ts` extension.
- One story file per component, matching component name.
- Use autodocs. Include variants, sizes, and test interactions with actions.
- Use `$lib` aliases or relative imports.

## Tools (AI Coding Agent Interaction)

- When you make a change to the UI, use the `screenshot` tool to show the changes.
- If the user asks for a complex task to be performed, find any relevant files and call the `architect` tool to get a plan and show it to the user. Use this plan as guidance for the changes you make, but maintain the existing patterns and structure of the codebase.
- After a complex task is performed, use the `codeReview` tool to create a diff and use the diff to conduct a code review of the changes.

## Additional

- Keep code short; commits semantic.
- Reusable logic in `src/lib/utils/` (e.g., `audioUtils.ts`).
- (Database migrations not applicable for MVP).

## IMPORTANT (AI Coding Agent Workflow):

- After all changes are made, ALWAYS build the SvelteKit frontend application using its Vite build process (e.g., by running `vite build` within the frontend package directory, or the equivalent command configured in your monorepo for the frontend package). Ignore warnings, fix errors.
- Always add a one-sentence summary of changes to `.cursor-updates` file in markdown format at the end of every agent interaction.
- If you forget, the user can type the command "finish" and you will run the build (as described above) and update `.cursor-updates`.
- Finally, update git with `git add . && git commit -m "..."`. Don't push.
```